{"version":3,"sources":["meteor://ðŸ’»app/lib/reactive-state.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,CAAC,CAAC,OAAO,GAAG,UAAS,GAAG,EAAE;AACxB,MAAI,CAAC,CAAC,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE,OAAO,EAAE,CAAC;AAChC,MAAI,IAAI,GAAG,EAAE,CAAC;AACd,OAAK,IAAI,GAAG,qCAAI,GAAG,GAAE,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;;AAEpC,MAAI,UAAU,EAAE,mBAAmB,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;AAC/C,SAAO,IAAI,CAAC;CACb,CAAC;;AAEF,IAAI,UAAU,GAAG,CAAC,GAAC,QAAQ,EAAE,IAAI,GAAC,CAAC,oBAAoB,CAAC,UAAU,CAAC,CAAC;;;;;AAKpE,IAAI,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC,YAAE,EAAI;AAC5B,SAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,EAAE,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,EAAE,KAAK,CAAC,IAAI,CAAC,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAE;CAC9E,CAAC,CAAC;;;;AAIH,IAAI,SAAS,GAAG,KAAK,CAAC,KAAK,CAAC,YAAE,EAAI;AAChC,SAAQ,CAAC,CAAC,QAAQ,CAAC,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,EAAE,KAAK,CAAC,CAAE;CACnD,CAAC,CAAC;;AAEH,UAAU,CAAC,aAAa;AACX,WADoB,aAAa,GAC9B;sCADiB,aAAa;;AAE1C,QAAI,IAAI,GAAG,IAAI,CAAC;;;AAGhB,QAAI,CAAC,OAAO,GAAG,SAAS,CAAC;;;AAGzB,QAAI,CAAC,IAAI,GAAG,EAAE,CAAC;;;AAGf,QAAI,CAAC,KAAK,GAAG,EAAE,QAAQ,EAAE,EAAE,EAAE,GAAG,EAAE,IAAI,OAAO,CAAC,UAAU,EAAE,EAAE,CAAC;;;AAG7D,QAAI,CAAC,sBAAsB,GAAG,EAAE,CAAC;;;AAGjC,QAAI,CAAC,qBAAqB,GAAG,EAAE,CAAC;GACjC;;;;;;AAlB8B,eAAa,WAuB5C,aAAa;AAAA,2BAAC,OAAO,EAAE;AACrB,UAAI,KAAK,CAAC,IAAI,CAAC,OAAO,EAAE,MAAM,CAAC,EAAC;AAC9B,eAAO,GAAG,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;OAC9B,MAAM,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,OAAO,EAAE,KAAK,CAAC,EAAE;AACtC,cAAM,IAAI,KAAK,CAAC,iBAAiB,CAAC,CAAC;OACpC;AACD,aAAO,OAAO,CAAC;KAChB;;;;;;;;AA9B8B,eAAa,WAkC5C,gBAAgB;AAAA,8BAAC,OAAO,EAAE;AACxB,UAAI,KAAK,CAAC,IAAI,CAAC,OAAO,EAAE,KAAK,CAAC,EAAE;AAC9B,eAAO,CAAC,CAAC,MAAM,CAAC,OAAO,EAAE,UAAS,IAAI,EAAE,MAAM,EAAE;AAC9C,cAAI,IAAI,KAAK,EAAE,EACb,OAAO,MAAM,CAAC,KAEd,OAAO,IAAI,GAAG,GAAG,GAAG,MAAM,CAAC;SAC9B,EAAE,EAAE,CAAC,CAAC;OACR,MAAM,IAAI,KAAK,CAAC,IAAI,CAAC,OAAO,EAAE,MAAM,CAAC,EAAE;AACtC,eAAO,OAAO,CAAC;OAChB,MAAM;AACL,cAAM,IAAI,KAAK,CAAC,uCAAuC,CAAC,CAAC;OAC1D;KAEF;;;;;;;;AAhD8B,eAAa,WAoD5C,eAAe;AAAA,6BAAC,OAAO,EAAE;AACvB,UAAI,IAAI,GAAG,IAAI,CAAC;AAChB,UAAI,MAAM,GAAG,IAAI,CAAC;AAClB,UAAI,KAAK,GAAG,IAAI,CAAC,IAAI,CAAC;;;;AAItB,WAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AACvC,YAAI,KAAK,CAAC,IAAI,CAAC,KAAK,EAAE,SAAS,CAAC,IAC9B,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAC;AAC/C,gBAAM,GAAG,KAAK,CAAC;AACf,eAAK,GAAG,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;SAC3B,MAAM;;AAEL,iBAAO,IAAI,CAAC,OAAO,CAAC;SACrB;OACF;;;;;AAKD,UAAI,KAAK,CAAC,IAAI,CAAC,KAAK,EAAE,KAAK,CAAC,IAAI,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,EAAE,QAAQ,CAAC,EAAE;AAC/D,eAAO,KAAK,CAAC,GAAG,EAAE,CAAC;;;OAGpB,MAAM,IAAI,KAAK,CAAC,IAAI,CAAC,KAAK,EAAE,QAAQ,CAAC;;;AAGpC,cAAK,OAAO,KAAK,KAAK,WAAW,IAAM,CAAC,CAAC,KAAK,CAAC,WAAY,EACzD,OAAO,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,KAE1B,OAAO,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC;;AAG9B,iBAAO,KAAK,CAAC;KAChB;;;;;;;;;;AAvF8B,eAAa,WA6F5C,mBAAmB;AAAA,iCAAC,OAAO,EAAE,KAAK,EAAE;AAClC,UAAI,IAAI,GAAG,IAAI,CAAC;AAChB,UAAI,GAAG,GAAG,EAAE,CAAC;AACb,UAAI,WAAW,GAAG,GAAG,CAAC;AACtB,UAAI,QAAQ,GAAG,IAAI,CAAC;AACpB,WAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AACvC,gBAAQ,GAAG,WAAW,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,GAAG,WAAW,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC;AACnE,YAAI,CAAC,KAAM,OAAO,CAAC,MAAM,GAAG,CAAE,EAAE;AAC9B,qBAAW,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC;SACjC,MAAM;AACL,qBAAW,GAAG,QAAQ,CAAC;SACxB;OACF;AACD,aAAO,GAAG,CAAC;KACZ;;;;;;;;AA3G8B,eAAa,WA+G5C,WAAW;AAAA,yBAAC,OAAO,EAAE;AACnB,UAAI,IAAI,GAAG,IAAI,CAAC;AAChB,UAAI,WAAW,GAAG,IAAI,CAAC,KAAK,CAAC;AAC7B,UAAI,QAAQ,GAAG,IAAI,CAAC;AACpB,WAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AACvC,gBAAQ,GAAG,WAAW,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,GACzC,WAAW,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,IAChC,EAAE,QAAQ,EAAE,EAAE,EAAE,GAAG,EAAE,IAAI,OAAO,CAAC,UAAU,EAAE,EAAE,CAAC;AAClD,mBAAW,GAAG,QAAQ,CAAC;OACxB;AACD,aAAO,WAAW,CAAC,GAAG,CAAC;KACxB;;;;;;;;AA1H8B,eAAa,WA8H5C,SAAS;AAAA,uBAAC,OAAO,EAAE,KAAK,EAAE;AACxB,UAAI,IAAI,GAAG,IAAI,CAAC;AAChB,UAAI,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;AACrB,WAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AACvC,YAAI,CAAC,KAAK,OAAO,CAAC,MAAM,GAAG,CAAC,EAC1B,IAAI,GAAG,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,KAEjD,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC;OAC5B;AACD,UAAI,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC;KAC1B;;;;;;;;;AAxI8B,eAAa,WA6I5C,OAAO;AAAA,qBAAC,OAAO,EAAC;AACd,UAAI,IAAI,GAAG,IAAI,CAAC;AAChB,UAAI,GAAG,GAAG,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;AACpC,SAAG,CAAC,MAAM,EAAE,CAAC;KACd;;;;;;;;AAjJ8B,eAAa,WAqJ5C,UAAU;AAAA,wBAAC,OAAO,EAAE;AAClB,UAAI,IAAI,GAAG,IAAI,CAAC;AAChB,UAAI,GAAG,GAAG,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;AACpC,SAAG,CAAC,OAAO,EAAE,CAAC;KACf;;;;;;;;;AAzJ8B,eAAa,WA8J5C,UAAU;AAAA,wBAAC,MAAM,EAAE,MAAM,EAAoB;UAAlB,WAAW,yDAAG,EAAE;;AACzC,UAAI,IAAI,GAAG,IAAI,CAAC;;AAEhB,UAAI,KAAK,CAAC,IAAI,EAEd,KAAK,IAAI,GAAG,qCAAI,MAAM,GAAE;AACtB,YAAI,MAAM,CAAC,cAAc,CAAC,GAAG,CAAC,EAAE;;;;AAI9B,cAAI,OAAO,aAAO,WAAW,CAAC,CAAC;AAC/B,iBAAO,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;;;;AAIlB,cAAK,MAAM,KAAK,SAAS,IAAK,KAAK,CAAC,IAAI,CAAC,MAAM,EAAE,SAAS,CAAC,EAAE;AAC3D,mBAAO;WACR,MAAM,IAAI,CAAC,CAAC,CAAC,OAAO,CAAC,MAAM,CAAC,GAAG,CAAC,EAAE,MAAM,CAAC,GAAG,CAAC,CAAC,EAAE;;;;AAI/C,gBAAI,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC;;;AAGzB,gBAAI,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,EAAE,MAAM,CAAC,EAAE;;;AAGnC,kBAAI,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,EAAE,MAAM,CAAC,EAAE;AACpC,sBAAM,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC;eAClB;AACD,kBAAI,CAAC,UAAU,CAAC,MAAM,CAAC,GAAG,CAAC,EAAE,MAAM,CAAC,GAAG,CAAC,EAAE,OAAO,CAAC,CAAC;aAEpD,MAAM,IAAK,MAAM,CAAC,GAAG,CAAC,KAAK,SAAS,IACzB,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,EAAE,SAAS,CAAE,EAAE;;;AAG/C,qBAAO;aACR,MAAM;;AAEL,oBAAM,CAAC,GAAG,CAAC,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC;aAC3B;WACF;SACF;OACF;KACF;;;;;;;;;;;;AA1M8B,eAAa,WAkN5C,YAAY;AAAA,0BAAC,OAAO,EAAE,IAAI,EAAE;AAC1B,UAAI,IAAI,GAAG,IAAI,CAAC;AAChB,aAAO,CAAC,OAAO,CAAC,YAAM;AACpB,YAAI,QAAQ,GAAG,IAAI,CAAC,eAAe,CAAC,OAAO,CAAC,CAAC;AAC7C,YAAI,MAAM,GAAG,IAAI,CAAC,QAAQ,CAAC,CAAC;;AAE5B,YAAK,MAAM,IAAM,OAAO,MAAM,KAAK,QAAS,IACvC,MAAM,CAAC,KAAK,KAAK,SAAU,EAAE;AAChC,cAAI,CAAC,UAAU,CAAC,OAAO,EAAE,MAAM,CAAC,KAAK,EAAE,CAAC,CAAC;SAC1C,MAAM,IAAI,KAAK,CAAC,IAAI,CAAC,MAAM,EAAE,KAAK,CAAC,EAAE;AACpC,cAAI,CAAC,SAAS,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;SACjC,MAAM;AACL,cAAI,CAAC,UAAU,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;SAClC;OACF,CAAC,CAAC;KACJ;;;;;;;;AAjO8B,eAAa,WAqO5C,SAAS;AAAA,uBAAC,OAAO,EAAE,QAAQ,EAAE;AAC3B,UAAI,IAAI,GAAG,IAAI,CAAC;AAChB,UAAI,CAAC,SAAS,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;KACnC;;;;;;;;;AAxO8B,eAAa,WA6O5C,UAAU;AAAA,wBAAC,OAAO,EAAE,QAAQ,EAAE;AAC5B,UAAI,IAAI,GAAG,IAAI,CAAC;AAChB,UAAI,eAAe,GAAG,IAAI,CAAC,mBAAmB,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;AAClE,UAAI,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,EAAE,eAAe,CAAC,CAAC;KAC7C;;;;;;;;AAjP8B,eAAa,WAqP5C,GAAG;AAAA,iBAAC,OAAO,EAAE,QAAQ,EAAE;AACrB,UAAI,IAAI,GAAG,IAAI,CAAC;AAChB,aAAO,GAAG,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC;;AAEtC,OAAC,CAAC,IAAI,CAAC,IAAI,CAAC,sBAAsB,EAAE,UAAC,IAAI,EAAK;AAC5C,YAAI,KAAK,GAAG,IAAI,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;AACpC,YAAI,KAAK,KAAK,SAAS,EACrB,QAAQ,GAAG,KAAK,CAAC;OACpB,CAAC,CAAC;;AAEH,UAAI,KAAK,CAAC,IAAI,CAAC,QAAQ,EAAE,QAAQ,CAAC,EAChC,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC,KAClC,IAAI,KAAK,CAAC,IAAI,CAAC,QAAQ,EAAE,KAAK,CAAC,EAClC,IAAI,CAAC,SAAS,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC,KAElC,IAAI,CAAC,UAAU,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;;AAErC,OAAC,CAAC,IAAI,CAAC,IAAI,CAAC,qBAAqB,EAAE,UAAC,IAAI,EAAK;AAC3C,YAAI,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;OACzB,CAAC,CAAC;KACJ;;;;;;;;AAzQ8B,eAAa,WA6Q5C,MAAM;AAAA,oBAAC,OAAO,EAAE,QAAQ,EAAE;AACxB,UAAI,IAAI,GAAG,IAAI,CAAC;;AAEhB,UAAI,KAAK,CAAC,IAAI,CAAC,QAAQ,EAAE,QAAQ,CAAC,EAAE;AAClC,YAAI,CAAC,GAAG,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;OAC7B,MAAM;AACL,cAAM,IAAI,KAAK,CAAC,2BAA2B,CAAC,CAAC;OAC9C;KACF;;;;;;;;;;AArR8B,eAAa,WA2R5C,YAAY;AAAA,0BAAC,EAAE,EAAE;AACf,UAAI,IAAI,GAAG,IAAI,CAAC;AAChB,UAAI,CAAC,sBAAsB,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;KACtC;;;;;;;;;AA9R8B,eAAa,WAmS5C,WAAW;AAAA,yBAAC,EAAE,EAAE;AACd,UAAI,IAAI,GAAG,IAAI,CAAC;AAChB,UAAI,CAAC,qBAAqB,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;KACrC;;;;;;;;;AAtS8B,eAAa,WA2S5C,GAAG;AAAA,iBAAC,OAAO,EAAE;AACX,UAAI,IAAI,GAAG,IAAI,CAAC;AAChB,aAAO,GAAG,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC;;AAEtC,UAAI,KAAK,GAAG,IAAI,CAAC,eAAe,CAAC,OAAO,CAAC,CAAC;;AAE1C,UAAI,OAAO,CAAC,MAAM,EAAE;AAClB,YAAI,CAAC,OAAO,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;OAC9B;;AAED,aAAO,KAAK,CAAC;KACd;;;;;SAtT8B,aAAa;IAuT7C,CAAC;;;AAGF,aAAa,GAAG,UAAU,CAAC,aAAa,CAAC,mF","file":"/packages/meteorflux_reactive-state.js","sourcesContent":["// Retrieve all the property names of an object. Mising in Meteor's underscore.\n_.allKeys = function(obj) {\n  if (!_.isObject(obj)) return [];\n  var keys = [];\n  for (var key in obj) keys.push(key);\n  // Ahem, IE < 9.\n  if (hasEnumBug) collectNonEnumProps(obj, keys);\n  return keys;\n};\n// Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.\nvar hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');\n\n// Match helper to know if a javascript object was created from a class (or\n// prototype) with a syntax like 'var instance = new SomeClass();'. It returns\n// false if the object is a plain javascript object.\nvar Class = Match.Where(ob => {\n  return (!Match.test(ob, Object) && !Match.test(ob, Array) && _.isObject(ob));\n});\n\n// Match helper to check if something is an object but not an array. Any type\n// of object, not just plain objects, so classes included.\nvar AnyObject = Match.Where(ob => {\n  return (_.isObject(ob) && !Match.test(ob, Array));\n});\n\nMeteorFlux.ReactiveState = class ReactiveState {\n  constructor() {\n    let self = this;\n\n    // Value to retrieve if a key is not set yet.\n    self._NOTSET = undefined;\n\n    // Object to store all the values.\n    self._obj = {};\n\n    // Object to store all the dependencies.\n    self._deps = { children: {}, dep: new Tracker.Dependency() };\n\n    // Array to store the beforeChange callbacks.\n    self._beforeChangeCallbacks = [];\n\n    // Array to store the afterChange callbacks.\n    self._afterChangeCallbacks = [];\n  }\n\n  // This function gets a keypath and checks if its a string like \"author.name\"\n  // or if it is an array. In any case, it will return the corresponding array\n  // value. For example: 'a.b' returns ['a', 'b'].\n  _checkKeyPath(keyPath) {\n    if (Match.test(keyPath, String)){\n      keyPath = keyPath.split('.');\n    } else if (!Match.test(keyPath, Array)) {\n      throw new Error('Invalid keypath');\n    }\n    return keyPath;\n  }\n\n  // This function gets a keyPath (array) and generates a new keyPath in\n  // string format. For example: ['a', 'b'] returns 'a.b'.\n  _keyPathToString(keyPath) {\n    if (Match.test(keyPath, Array)) {\n      return _.reduce(keyPath, function(memo, string) {\n        if (memo === '')\n          return string;\n        else\n          return memo + '.' + string;\n      }, '');\n    } else if (Match.test(keyPath, String))Â {\n      return keyPath;\n    } else {\n      throw new Error('keyPath must be an Array or a String.');\n    }\n\n  }\n\n  // This function gets a keyPath (array) and returns the value stored in\n  // ReactiveState for it. If is not set yet, it will return the _NOTSET value.\n  _getValueInPath(keyPath) {\n    let self = this;\n    let parent = null;\n    let value = self._obj;\n\n    // Check to see if there is a value in self._obj but maintain the parent\n    // in case we have to bind because it is a function.\n    for (let i = 0; i < keyPath.length; i++) {\n      if (Match.test(value, AnyObject) &&\n        _.indexOf(_.allKeys(value), keyPath[i]) !== -1){\n        parent = value;\n        value = value[keyPath[i]];\n      } else {\n        // If nothing is found, we return the value of _NOTSET.\n        return self._NOTSET;\n      }\n    }\n\n    // Now, check if it is a class and has a get value. If it does, then it's\n    // probably some kind of Reactive source. Let's return the result of its\n    // get function.\n    if (Match.test(value, Class) && Match.test(value.get, Function)) {\n      return value.get();\n    // Next thing we check if the value itself is a function. If it is, then\n    // we bind it to its parent to it has access to the correct object.\n    } else if (Match.test(value, Function))\n      // We check if we are on Blaze or not as well. If we are not, we execute\n      // the function, but if we are, we leave Blaze do so.\n      if ((typeof Blaze !== 'undefined') && (!!Blaze.currentView))\n        return value.bind(parent);\n      else\n        return value.bind(parent)();\n    else\n      // If none of the special cases above is true, just return the value.\n      return value;\n  }\n\n  // This function gets a keyPath (array) and a value and creates a new object\n  // with the proper structure from the keyPath and the value stored in its\n  // correct place. For example:\n  // ['a', 'b'] and 'data' returns { a: { b: 'data' } }\n  _createObjFromValue(keyPath, value) {\n    let self = this;\n    let obj = {};\n    let currentNode = obj;\n    let nextNode = null;\n    for (let i = 0; i < keyPath.length; i++) {\n      nextNode = currentNode[keyPath[i]] = currentNode[keyPath[i]] || {};\n      if (i === (keyPath.length - 1)) {\n        currentNode[keyPath[i]] = value;\n      } else {\n        currentNode = nextNode;\n      }\n    }\n    return obj;\n  }\n\n  // This function takes keyPath (array) and returns the same node in the\n  // dependency object. If it doesn't exist, it will create it.\n  _getDepNode(keyPath) {\n    let self = this;\n    let currentNode = self._deps;\n    let nextNode = null;\n    for (let i = 0; i < keyPath.length; i++) {\n      nextNode = currentNode.children[keyPath[i]] =\n        currentNode.children[keyPath[i]] ||\n        { children: {}, dep: new Tracker.Dependency() };\n      currentNode = nextNode;\n    }\n    return currentNode.dep;\n  }\n\n  // This function takes keyPath (array) and stores the value passed without\n  // modifying it.\n  _setValue(keyPath, value) {\n    let self = this;\n    let node = self._obj;\n    for (var i = 0; i < keyPath.length; i++) {\n      if (i !== keyPath.length - 1)\n        node = node[keyPath[i]] = node[keyPath[i]] || {};\n      else\n        node[keyPath[i]] = value;\n    }\n    self._changeDep(keyPath);\n  }\n\n  // This function adds a dependency for the keyPath (array). This means that\n  // if a Tracker computation is running, it will create the reactive\n  // dependency.\n  _addDep(keyPath){\n    let self = this;\n    let dep = self._getDepNode(keyPath);\n    dep.depend();\n  }\n\n  // This function triggers a dependency for a value which has changed. The\n  // Tracker computations dependent will be invalidated.\n  _changeDep(keyPath) {\n    let self = this;\n    let dep = self._getDepNode(keyPath);\n    dep.changed();\n  }\n\n  // This function gets the old object tree, a new one (created with\n  // _createObjFromValue) and a keyPath (array) and merges both together.\n  // The result is the new state.\n  _changeObj(oldObj, newObj, rootKeyPath = []) {\n    let self = this;\n\n    if (Match.test)\n\n    for (var key in newObj) {\n      if (newObj.hasOwnProperty(key)) {\n\n        // We need to clone the array so we don't modify the rootKeyPath and\n        // it is still valid in the next for iteration.\n        var keyPath = [...rootKeyPath];\n        keyPath.push(key);\n\n        // In the case that there is a previous object and the new value is\n        // undefined instead of an object, do nothing.\n        if ((newObj === undefined) && Match.test(oldObj, AnyObject)) {\n          return;\n        } else if (!_.isEqual(oldObj[key], newObj[key])) {\n\n          // If they are not equal, the first thing to do it to mark this\n          // keyPath as changed to trigger all the Tracker.autoruns.\n          self._changeDep(keyPath);\n\n          // Check if it is an object\n          if (Match.test(newObj[key], Object)) {\n\n            // Both are objects, use _changeObj again.\n            if (!Match.test(oldObj[key], Object)) {\n              oldObj[key] = {};\n            }\n            self._changeObj(oldObj[key], newObj[key], keyPath);\n\n          } else if ((newObj[key] === undefined) &&\n                     (Match.test(oldObj[key], AnyObject))) {\n            // If it's undefined and the old value is a an object, do nothing\n            // because maybe it's a function not returning.\n            return;\n          } else {\n            // If it's not that case, we just overwrite the value.\n            oldObj[key] = newObj[key];\n          }\n        }\n      }\n    }\n  }\n\n  // This function gets a keyPath (array) and a function and puts it in a\n  // Tracker computation. The function will be executed and the result will be\n  // stored in ReactiveState. This means we don't store function, we store the\n  // resulting objects. If the function is reactive and something inside it\n  // changes, this Tracker computation will be run again and ReactiveState will\n  // be updated with the correct values.\n  _setFunction(keyPath, func) {\n    let self = this;\n    Tracker.autorun(() => {\n      let oldValue = self._getValueInPath(keyPath);\n      let result = func(oldValue);\n      // check if it's a Mongo Cursor and run fetch.\n      if ((result) && (typeof result === 'object') &&\n          (result.fetch !== undefined)) {\n        self._setObject(keyPath, result.fetch());\n      } else if (Match.test(result, Class)) {\n        self._setClass(keyPath, result);\n      } else {\n        self._setObject(keyPath, result);\n      }\n    });\n  }\n\n  // This function gets a keyPath (array) and an instance of some class and\n  // stores its value in ReactiveState.\n  _setClass(keyPath, instance) {\n    let self = this;\n    self._setValue(keyPath, instance);\n  }\n\n  // This function gets a keyPath (array) and a new value and it creates a new\n  // object with the value and merges it with the old object tree. Then it\n  // registers the Blaze helper.\n  _setObject(keyPath, newValue) {\n    let self = this;\n    let newObjFromValue = self._createObjFromValue(keyPath, newValue);\n    self._changeObj(self._obj, newObjFromValue);\n  }\n\n  // This public method gets a keyPath (string or array) and a new value and\n  // stores it in the ReactiveState object tree.\n  set(keyPath, newValue) {\n    let self = this;\n    keyPath = self._checkKeyPath(keyPath);\n\n    _.each(self._beforeChangeCallbacks, (func) => {\n      let value = func(keyPath, newValue);\n      if (value !== undefined)\n        newValue = value;\n    });\n\n    if (Match.test(newValue, Function))\n      self._setFunction(keyPath, newValue);\n    else if (Match.test(newValue, Class))\n      self._setClass(keyPath, newValue);\n    else\n      self._setObject(keyPath, newValue);\n\n    _.each(self._afterChangeCallbacks, (func) => {\n      func(keyPath, newValue);\n    });\n  }\n\n  // This public method gets a keyPath (string or array) and a new value and\n  // stores it in the ReactiveState object tree.\n  modify(keyPath, modifier) {\n    let self = this;\n\n    if (Match.test(modifier, Function)) {\n      self.set(keyPath, modifier);\n    } else {\n      throw new Error('Invalid modifier function');\n    }\n  }\n\n  // This is a public hook to add a callback which will be called before any\n  // change is triggered. The callback will receive the keyPath (in array\n  // format) and the new value. If it returns something different than undefined\n  // the new value will be overwriten.\n  beforeChange(cb) {\n    let self = this;\n    self._beforeChangeCallbacks.push(cb);\n  }\n\n  // This is a public hook to add a callback which will be called after any\n  // change is triggered. The callback will receive the keyPath (in array\n  // format) and the new value.\n  afterChange(cb) {\n    let self = this;\n    self._afterChangeCallbacks.push(cb);\n  }\n\n  // This public method gets a keyPath (string or array) and returns the\n  // correct value of the object tree. If a Tracker computation is currently\n  // active it will add a dependency.\n  get(keyPath) {\n    let self = this;\n    keyPath = self._checkKeyPath(keyPath);\n\n    let value = self._getValueInPath(keyPath);\n\n    if (Tracker.active) {\n      self._addDep(keyPath, value);\n    }\n\n    return value;\n  }\n};\n\n// Creates a global to be exported.\nReactiveState = MeteorFlux.ReactiveState;\n"]}